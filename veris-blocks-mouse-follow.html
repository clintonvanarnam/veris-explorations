<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Veris SVG Grid</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 1000vh;
      background: black;
      overflow: hidden;
    }

    svg {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Load libraries -->
 <!-- Load p5 core library -->
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.2/lib/p5.min.js"></script>

<!-- Load p5.js-svg renderer from a known working version -->
<script src="https://cdn.jsdelivr.net/npm/p5.js-svg@1.1.1/dist/p5.svg.min.js"></script>

  <!-- Your sketch -->
  <script>

let svgGraphic;
let cellPositions = [];
let startCount = 100;
let minCount = 1;
let currentCount = startCount;

let patternRectWidthRatio = 1;
let patternRectHeightRatio = 146 / 419;
let patternRowSpacing = 1;
let patternColSpacing = 1;

function preload() {
  svgGraphic = loadSVG("assets/1.svg");
}

function setup() {
  createCanvas(windowWidth, windowHeight, SVG);
  noFill();
  noLoop(); // Weâ€™ll redraw manually on mouse move or scroll
  updateGrid();
}

function updateGrid() {
  cellPositions = [];

  let bestCols = 1;
  let bestRows = 1;
  let minDiff = Infinity;
  for (let rows = 1; rows <= currentCount; rows++) {
    let cols = ceil(currentCount / rows);
    let gridAspect = (cols / rows) * (height / width);
    let diff = abs(gridAspect - 1);
    if (cols * rows >= currentCount && diff < minDiff) {
      minDiff = diff;
      bestCols = cols;
      bestRows = rows;
    }
  }

  let cols = bestCols;
  let rows = bestRows;
  let colSpacingPx = patternColSpacing * 8;
  let rowSpacingPx = patternRowSpacing * 8;
  let gridW = (width - colSpacingPx * (cols - 1)) / cols;
  let gridH = (height - rowSpacingPx * (rows - 1)) / rows;
  let totalGridW = cols * gridW + (cols - 1) * colSpacingPx;
  let totalGridH = rows * gridH + (rows - 1) * rowSpacingPx;
  let offsetX = (width - totalGridW) / 2;
  let offsetY = (height - totalGridH) / 2;

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      let gx = col * (gridW + colSpacingPx) + offsetX;
      let gy = row * (gridH + rowSpacingPx) + offsetY;
      cellPositions.push({ x: gx, y: gy, w: gridW, h: gridH });
    }
  }

  redraw();
}

function draw() {
  clear();
  for (let cell of cellPositions) {
    const { x, y, w, h } = cell;
    let cx = x + w / 2;
    let cy = y + h / 2;
    let angle = atan2(mouseY - cy, mouseX - cx);

    push();
    translate(cx, cy);
    rotate(angle);

    let svgW = 472;
    let svgH = 188;
    let svgAspect = svgW / svgH;
    let cellAspect = w / h;
    let drawW, drawH;
    if (cellAspect > svgAspect) {
      drawH = h;
      drawW = svgAspect * drawH;
    } else {
      drawW = w;
      drawH = drawW / svgAspect;
    }

    // Instead of shape(), use image() for SVG fallback if shape is not defined
    if (typeof shape === 'function') {
      shape(svgGraphic, -drawW / 2, -drawH / 2, drawW, drawH);
    } else {
      image(svgGraphic, -drawW / 2, -drawH / 2, drawW, drawH);
    }
    pop();
  }
}

function mouseMoved() {
  redraw(); // Manually trigger
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  updateGrid();
}

window.addEventListener('scroll', () => {
  let scrollY = window.scrollY;
  let maxScroll = document.body.scrollHeight - window.innerHeight;
  let percent = Math.min(scrollY / maxScroll, 1);
  let newCount = Math.round(startCount - percent * (startCount - minCount));
  if (newCount !== currentCount) {
    currentCount = newCount;
    updateGrid();
  }
});

  </script>
</body>
</html>